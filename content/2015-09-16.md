Section Window
==============

-	view-info 到底是与什么绑定的？

通过 `CKEWindow::GetObjectViewInfo` 这个函数的参数可知，View Info 最早的依据应该是数据对象的 UUID，但不要忘了这是一个成员函数，`this` 指针所代表的 `CKEWindow` 对象，也是它的触发条件之一。

更细致的观察一下 `CKEWindow` 对象，它维系了一个以 UUID 为 key, View Info 指针为 value 的 Map。而某数据对象的 View Info 便可以通过这个 Map 来管理。实例化的时候 insert into Map，需要的时候，从 Map 里取出。

总结一下，view-info 是由两个对象共同决定的：

-	window （哪个窗口）
-	data （哪个数据）

---

> **Section Window 的必备显示需求**
>
> 1.	无论是 line number 的改变，还是 section 本身的切换，都不应该影响当前的编辑状态。
> 2.	如果此刻正在编辑中（未完成状态），进行上述的两种切换，则应该放弃最后一次编辑，全部来一次 reset。

---

-	昨天的问题

似乎在 new item 的时候，同时 new 一个 section 的实例成了一个很好的办法。但随之而来的问题也来了：这个实例是一个**孤岛**。它是树上数据对象的一个副本，而有些东西是无法 copy 来的，首当其冲，便是树上的父子关系。没有这层关系，即使拿到了 section 对象，也无法得知其 survey，无法得知同级的其他 section。所以连 UTM 信息都无法拿到。得不偿失。

想要继续保留这些关系，需要让副本和源对象建立联系。领导提供了一个以往的设计思路：让 `CKEObject` 类除了维护一个 `ObjectID` 以外，再维护一个 `ReferenceID`。这个要和 C++ 里的引用加以区分。有了这个 `ReferenceID`，新 new 的实例便不再是孤岛。而成了源对象的一个顾问。我可以通过源对象去找到这个顾问，那么源对象为主的思路依然不变，只是需要单独存储的数据信息存到副本对象里去即可。这样一来，以往的结构得以兼容，同时也不会轻易破坏源对象中的数据索引。

---

上述思路的确可以解决咱们目前的困境，但还是稍显曲线救国。如果回到最开始的问题上。我希望不同窗口可以显示不同的 Section 数据。等等，真的是 Section 数据吗？更细化一些呢，实际是 SeismicDataVolume 数据（以下简称体数据）吧。如果要更细，那么就是一个二维数组，在 inline, xline 的具体情况下，也就是一个一维数组。那么，问题就可以转变为：不同 window 显示不同的体数据 (or float array)

后面细化了，前面呢？即使在一个 window 里，我们有时也是需要显示两个体数据的，如前景、背景。那么更准确的定位，应该是针对 item 的。即：

**不同 item 显示不同的体数据**

这样分析一番，实际上这个问题的主角应该是 item 和 体数据。那么很简单的设计便是：把数据体委托给 item。我们不需要创造新的对象实例，仅仅让 item 来维系数据的索引即可。
